#!/usr/bin/env python
# encoding: utf-8
import os
import re
from uuid import uuid4
from batch import BatchBase
from library.utility import *
import yaml
import mimetypes
import zipfile


class Batch(BatchBase):

    args = None
    mimetype_filepath = ''
    meta_inf_dirpath = ''
    oebps_dirpath = ''
    oebps_styles_dirpath = ''
    settings = {}
    resources = {}
    chapters = []
    manifests = {}
    spines = {}

    def __init__(self):
        '''
        コンストラクタ
        '''
        batch_name = 'Create epub'
        set_argument_settings = []
        # 裏の顔
        set_argument_settings.append({'short_name': '-i', 'long_name': '--input_setting_file', 'destination': 'input_setting_file',
                                      'default_value': r'C:\Users\kenic\Dropbox\Novels\tools\create_epub\data\epub\裏の顔\setting.yaml', 'help': '設定ファイルのパス'})
        set_argument_settings.append({'short_name': '-o', 'long_name': '--output_dir', 'destination': 'output_dir',
                                      'default_value': r'C:\Users\kenic\Dropbox\Novels\tools\create_epub\data\epub\裏の顔\output', 'help': '出力ディレクトリのパス'})
        # 蜃気楼
        # set_argument_settings.append({'short_name': '-i', 'long_name': '--input_setting_file', 'destination': 'input_setting_file', 'default_value': r'C:\Users\kenic\Dropbox\Novels\tools\create_epub\data\epub\蜃気楼\setting.yaml', 'help': '設定ファイルのパス'})
        # set_argument_settings.append({'short_name': '-o', 'long_name': '--output_dir', 'destination': 'output_dir', 'default_value': r'C:\Users\kenic\Dropbox\Novels\tools\create_epub\data\epub\蜃気楼\output', 'help': '出力ディレクトリのパス'})
        set_argument_settings.append({'short_name': '-d', 'long_name': '--debug_flag',
                                      'destination': 'debug_flag', 'default_value': '0', 'help': 'デバッグフラグ'})
        super(Batch, self).__init__(batch_name, set_argument_settings)

    def main(self, args):
        '''
        メイン処理
        '''

        self.args = args

        # ファイルチェック
        if not FileSystem.exists_file(self.args.input_setting_file):
            raise BatchBase.BatchException('設定ファイルが見つかりません。')

        # 出力ディレクトリ作成
        if FileSystem.exists_file(self.args.output_dir):
            FileSystem.remove_directory(self.args.output_dir)
            self.info_log('出力ディレクトリのファイルを削除しました。 {0}'.format(
                self.args.output_dir))
        FileSystem.create_directory_tree(self.args.output_dir)

        # 設定ファイル読み込み
        self.load_setting_file()

        # mimetypeファイル作成
        self.create_mimetype()

        # META-INFディレクトリ作成
        self.create_meta_inf()
        self.create_meta_inf_container_xml()

        # OEBPSディレクトリ作成
        self.create_oebps()
        self.create_oebps_resources()
        self.create_oebps_styles()
        self.create_oebps_styles_style_css()

        # OEBPSディレクトリ内コンテンツファイル作成
        self.create_oebps_conver_xhtml()
        self.create_oebps_readme_xhtml()
        self.create_oebps_title_xhtml()
        self.create_oebps_chapter_xhtml()
        self.create_oebps_navigation_xhtml()
        self.create_oebps_rights_xhtml()
        self.create_oebps_content_opf()

        # epubファイル作成
        self.create_epub()

    def load_setting_file(self):
        '''
        設定ファイル読み込み、設定ファイル中のリソースを展開
        '''

        # 設定ファイル読み込み
        with open(self.args.input_setting_file, 'r', encoding='utf-8') as f:
            self.settings = yaml.load(f)
        self.info_log('設定ファイル読み込み')

        # リソース設定
        self.convert_yaml_to_list('setting', self.settings, self.resources)

        self.manifests['resources'] = []
        for resource in self.settings['resources']:
            if not FileSystem.exists_file(resource['filePath']):
                raise BatchBase.BatchException(
                    'ファイルが存在しません。: {0}'.format(resource['filePath']))
            properties = ''
            if 'type' in resource and resource['type'] == 'cover':
                properties = ' properties="cover-image"'
            self.manifests['resources'].append(
                '<item id="image{0}" href="{1}" media-type="{2}" {3} />'.format(
                    len(self.manifests['resources']) + 1,
                    './resources/' + os.path.basename(resource['filePath']),
                    mimetypes.guess_type(resource['filePath'])[0],
                    properties
                )
            )

        self.info_log('リソース読み込み')
        for key in self.resources:
            print(key + ' => ' + self.resources[key])

    def create_mimetype(self):
        '''
        ファイル作成 - /mimetype
        '''

        self.mimetype_filepath = os.path.join(self.args.output_dir, 'mimetype')

        if FileSystem.exists_file(self.mimetype_filepath):
            FileSystem.remove_file(self.mimetype_filepath)

        with open(self.mimetype_filepath, 'w', encoding='utf-8') as f:
            f.write('application/epub+zip')

        self.info_log('ファイル作成 - /mimetype')

    def create_meta_inf(self):
        '''
        ディレクトリ作成 - /META-INF
        '''

        self.meta_inf_dirpath = os.path.join(self.args.output_dir, 'META-INF')

        if FileSystem.exists_file(self.meta_inf_dirpath):
            FileSystem.remove_directory(self.meta_inf_dirpath)

        FileSystem.create_directory(self.meta_inf_dirpath)

        self.info_log('ディレクトリ作成 - /META-INF')

    def create_meta_inf_container_xml(self):
        '''
        ファイル作成 - /META-INF/container.xml
        '''

        container_xml_filepath = os.path.join(
            self.meta_inf_dirpath, 'container.xml')

        data = '''
<?xml version="1.0" encoding="UTF-8"?>
<container version="1.0" xmlns="urn:oasis:names:tc:opendocument:xmlns:container">
	<rootfiles>
		<rootfile full-path="OEBPS/content.opf" media-type="application/oebps-package+xml"/>
	</rootfiles>
</container>
'''

        if FileSystem.exists_file(container_xml_filepath):
            FileSystem.remove_file(container_xml_filepath)

        with open(container_xml_filepath, 'w', encoding='utf-8') as f:
            f.write(data.strip())

        self.info_log('ファイル作成 - /META-INF/container.xml')

    def create_oebps(self):
        '''
        ディレクトリ作成 - /OEBPS
        '''

        self.oebps_dirpath = os.path.join(self.args.output_dir, 'OEBPS')

        if FileSystem.exists_file(self.oebps_dirpath):
            FileSystem.remove_directory(self.oebps_dirpath)

        FileSystem.create_directory(self.oebps_dirpath)

        self.info_log('ディレクトリ作成 - /OEBPS')

    def create_oebps_resources(self):
        '''
        ディレクトリ作成 - /OEBPS/resources
        '''

        oebps_resources_dirpath = os.path.join(self.oebps_dirpath, 'resources')

        if FileSystem.exists_file(oebps_resources_dirpath):
            FileSystem.remove_directory(oebps_resources_dirpath)

        FileSystem.create_directory(oebps_resources_dirpath)

        self.info_log('ディレクトリ作成 - /OEBPS/resources')

        for resource in self.settings['resources']:
            FileSystem.copy_file(resource['filePath'], oebps_resources_dirpath)

    def create_oebps_styles(self):
        '''
        ディレクトリ作成 - /OEBPS/styles
        '''

        self.oebps_styles_dirpath = os.path.join(self.oebps_dirpath, 'styles')

        if FileSystem.exists_file(self.oebps_styles_dirpath):
            FileSystem.remove_directory(self.oebps_styles_dirpath)

        FileSystem.create_directory(self.oebps_styles_dirpath)

        self.info_log('ディレクトリ作成 - /OEBPS/styles')

    def create_oebps_styles_style_css(self):
        '''
        ファイル作成 - /OEBPS/styles/style.css
        '''

        oebps_styles_style_css_filepath = os.path.join(
            self.oebps_styles_dirpath, 'style.css')

        if FileSystem.exists_file(oebps_styles_style_css_filepath):
            FileSystem.remove_directory(oebps_styles_style_css_filepath)

        style_css_template_filepath = self.settings['templates']['style']['templateFilePath']

        if not FileSystem.exists_file(style_css_template_filepath):
            raise BatchBase.BatchException(
                'テンプレートファイルが見つかりません。: {0}'.format(style_css_template_filepath))

        FileSystem.copy_file(style_css_template_filepath,
                             self.oebps_styles_dirpath)

        self.manifests['styles'] = []
        self.manifests['styles'].append(
            '<item id="style_style" href="./styles/style.css" media-type="text/css" />')

        self.info_log('ファイル作成 - /OEBPS/styles/style.css')

    def create_oebps_conver_xhtml(self):
        '''
        ファイル作成 - /OEBPS/cover.xhml
        '''

        if not 'cover' in self.settings['templates']:
            self.info_log('coverが見つからないためスキップします。')
            return

        oebps_cover_xhtml = os.path.join(self.oebps_dirpath, 'cover.xhtml')
        cover_template_filepath = self.settings['templates']['cover']['templateFilePath']
        cover_data = ''

        # テンプレートファイルを読み込み
        if not FileSystem.exists_file(cover_template_filepath):
            raise BatchBase.BatchException(
                'テンプレートファイルが見つかりません。: {0}'.format(cover_template_filepath))

        with open(cover_template_filepath, 'r', encoding='utf-8') as f:
            cover_data = f.read()

        # テンプレートファイル内のコンテンツを置換
        if 'replaces' in self.settings['templates']['cover']:
            cover_data = self.content_replace(
                cover_data, self.settings['templates']['cover']['replaces'])
        cover_data = Convert.replace_by_hash_data(
            cover_data, self.resources, 'replace:')

        with open(oebps_cover_xhtml, 'w', encoding='utf-8') as f:
            f.write(cover_data)

        self.manifests['cover'] = []
        self.manifests['cover'].append(
            '<item id="htm_cover" href="./cover.xhtml" media-type="application/xhtml+xml" />')
        self.spines['cover'] = []
        self.spines['cover'].append('<itemref idref="htm_cover" />')

        self.info_log('ファイル作成 - /OEBPS/cover.xhml')

    def create_oebps_readme_xhtml(self):
        '''
        ファイル作成 - /OEBPS/readme.xhml
        '''

        if not 'readme' in self.settings['templates']:
            self.info_log('readmeが見つからないためスキップします。')
            return

        oebps_readme_xhtml = os.path.join(self.oebps_dirpath, 'readme.xhtml')
        readme_template_filepath = self.settings['templates']['readme']['templateFilePath']
        readme_data = ''

        if not FileSystem.exists_file(readme_template_filepath):
            raise BatchBase.BatchException(
                'テンプレートファイルが見つかりません。: {0}'.format(readme_template_filepath))

        with open(readme_template_filepath, 'r', encoding='utf-8') as f:
            readme_data = f.read()

        if 'replaces' in self.settings['templates']['readme']:
            readme_data = self.content_replace(
                readme_data, self.settings['templates']['readme']['replaces'])
        readme_data = Convert.replace_by_hash_data(
            readme_data, self.resources, 'replace:')

        with open(oebps_readme_xhtml, 'w', encoding='utf-8') as f:
            f.write(readme_data)

        self.manifests['readme'] = []
        self.manifests['readme'].append(
            '<item id="htm_readme" href="./readme.xhtml" media-type="application/xhtml+xml" />')
        self.spines['readme'] = []
        self.spines['readme'].append('<itemref idref="htm_readme" />')

        self.info_log('ファイル作成 - /OEBPS/readme.xhml')

    def create_oebps_title_xhtml(self):
        '''
        ファイル作成 - /OEBPS/title.xhml
        '''

        if not 'title' in self.settings['templates']:
            self.info_log('titleが見つからないためスキップします。')
            return

        oebps_title_xhtml = os.path.join(self.oebps_dirpath, 'title.xhtml')
        title_template_filepath = self.settings['templates']['title']['templateFilePath']
        title_data = ''

        if not FileSystem.exists_file(title_template_filepath):
            raise BatchBase.BatchException(
                'テンプレートファイルが見つかりません。: {0}'.format(title_template_filepath))

        with open(title_template_filepath, 'r', encoding='utf-8') as f:
            title_data = f.read()

        if 'replaces' in self.settings['templates']['title']:
            title_data = self.content_replace(
                title_data, self.settings['templates']['title']['replaces'])
        title_data = Convert.replace_by_hash_data(
            title_data, self.resources, 'replace:')

        with open(oebps_title_xhtml, 'w', encoding='utf-8') as f:
            f.write(title_data)

        self.manifests['title'] = []
        self.manifests['title'].append(
            '<item id="htm_title" href="./title.xhtml" media-type="application/xhtml+xml" />')
        self.spines['title'] = []
        self.spines['title'].append('<itemref idref="htm_title" />')

        self.info_log('ファイル作成 - /OEBPS/title.xhml')

    def create_oebps_chapter_xhtml(self):
        '''
        ファイル作成 - /OEBPS/chapter_{n}.xhml
        '''

        chapter_count = 0
        self.manifests['chapters'] = []
        self.spines['chapters'] = []

        for chapter in self.settings['chapters']:
            chapter_count += 1
            chapter_filename = 'chapter_{0}.xhtml'.format(chapter_count)

            if not FileSystem.exists_file(chapter['filePath']):
                raise BatchBase.BatchException(
                    'チャプターファイルが見つかりません。: {0}'.format(chapter['filePath']))

            replace_hash = {}
            chapter_body_data = ''

            # 本文取得、<br />付与、置換
            with open(chapter['filePath'], 'r', encoding='utf-8') as f:
                lines = f.read().splitlines()
                for line in lines:
                    if 'replaces' in chapter:
                        line = self.content_replace(line, chapter['replaces'])
                    line = Convert.replace_by_hash_data(
                        line, self.resources, 'replace:')
                    chapter_body_data = chapter_body_data + line + '<br />\n'

            # ルビ変換（{ruby:ルビ対象{ルビ}}を<ruby>ルビ対象<rt>ルビ</rt></ruby>に変換する）
            for ruby_replace in re.findall(r'\{ruby\:\w+\{\w+\}\}', chapter_body_data):
                for rubys in re.findall(r'\{ruby\:(\w+)\{(\w+)\}\}', ruby_replace):
                    if len(rubys) == 2:
                        ruby = rubys[0]
                        rt = rubys[1]
                        html = '<ruby>{0}<rt>{1}</rt></ruby>'.format(ruby, rt)
                        chapter_body_data = chapter_body_data.replace(
                            ruby_replace, html)

            # チャプターデータを置換データに追加
            replace_hash['$chapter.title'] = chapter['title']
            replace_hash['$chapter.filePath'] = './' + chapter_filename
            replace_hash['$chapter.body'] = chapter_body_data

            # チャプターデータを収集
            self.chapters.append({
                '$chapter.title': replace_hash['$chapter.title'],
                '$chapter.filePath': replace_hash['$chapter.filePath'],
            })

            # テンプレートファイル取得、置換
            oebps_chapter_xhtml = os.path.join(
                self.oebps_dirpath, chapter_filename)
            chapter_template_filepath = self.settings['templates']['chapter']['templateFilePath']
            chapter_data = ''

            if not FileSystem.exists_file(chapter_template_filepath):
                raise BatchBase.BatchException(
                    'テンプレートファイルが見つかりません。: {0}'.format(chapter_template_filepath))

            with open(chapter_template_filepath, 'r', encoding='utf-8') as f:
                chapter_data = f.read()

            chapter_data = Convert.replace_by_hash_data(
                chapter_data, replace_hash, 'replace:')

            with open(oebps_chapter_xhtml, 'w', encoding='utf-8') as f:
                f.write(chapter_data)

            self.manifests['chapters'].append(
                '<item id="htm_chapter{0}" href="./chapter_{0}.xhtml" media-type="application/xhtml+xml" />'.format(chapter_count))
            self.spines['chapters'].append(
                '<itemref idref="htm_chapter{0}" />'.format(chapter_count))

            self.info_log(
                'ファイル作成 - /OEBPS/chapter_{0}.xhml'.format(chapter_count))

    def create_oebps_navigation_xhtml(self):
        '''
        ファイル作成 - /OEBPS/navigation.xhml
        '''

        if not 'navigation' in self.settings['templates']:
            self.info_log('navigationが見つからないためスキップします。')
            return

        oebps_navigation_xhtml = os.path.join(
            self.oebps_dirpath, 'navigation.xhtml')
        navigation_template_filepath = self.settings['templates']['navigation']['templateFilePath']
        navigation_data = ''

        if not FileSystem.exists_file(navigation_template_filepath):
            raise BatchBase.BatchException(
                'テンプレートファイルが見つかりません。: {0}'.format(navigation_template_filepath))

        with open(navigation_template_filepath, 'r', encoding='utf-8') as f:
            navigation_data = f.read()

        if 'replaces' in self.settings['templates']['navigation']:
            navigation = []
            for replace in self.settings['templates']['navigation']['replaces']:
                if replace['placeHolder'] == 'navigation':
                    for chapter in self.chapters:
                        navigation.append(Convert.replace_by_hash_data(
                            replace['replaceContent'], chapter, 'replace:'))
                    replace['replaceContent'] = '\n'.join(navigation)
            navigation_data = self.content_replace(
                navigation_data, self.settings['templates']['navigation']['replaces'])
        navigation_data = Convert.replace_by_hash_data(
            navigation_data, self.resources, 'replace:')

        with open(oebps_navigation_xhtml, 'w', encoding='utf-8') as f:
            f.write(navigation_data)

        self.manifests['navigation'] = []
        self.manifests['navigation'].append(
            '<item id="htm_navigation"	href="./navigation.xhtml" media-type="application/xhtml+xml" properties="nav" />')
        self.spines['navigation'] = []
        self.spines['navigation'].append('<itemref idref="htm_navigation" />')

        self.info_log('ファイル作成 - /OEBPS/navigation.xhml')

    def create_oebps_rights_xhtml(self):
        '''
        ファイル作成 - /OEBPS/rights.xhml
        '''

        if not 'rights' in self.settings['templates']:
            self.info_log('rightsが見つからないためスキップします。')
            return

        oebps_rights_xhtml = os.path.join(self.oebps_dirpath, 'rights.xhtml')
        rights_template_filepath = self.settings['templates']['rights']['templateFilePath']
        rights_data = ''

        if not FileSystem.exists_file(rights_template_filepath):
            raise BatchBase.BatchException(
                'テンプレートファイルが見つかりません。: {0}'.format(rights_template_filepath))

        with open(rights_template_filepath, 'r', encoding='utf-8') as f:
            rights_data = f.read()

        if 'replaces' in self.settings['templates']['rights']:
            rights_data = self.content_replace(
                rights_data, self.settings['templates']['rights']['replaces'])
        rights_data = Convert.replace_by_hash_data(
            rights_data, self.resources, 'replace:')

        with open(oebps_rights_xhtml, 'w', encoding='utf-8') as f:
            f.write(rights_data)

        self.manifests['rights'] = []
        self.manifests['rights'].append(
            '<item id="htm_rights" href="./rights.xhtml" media-type="application/xhtml+xml" />')
        self.spines['rights'] = []
        self.spines['rights'].append('<itemref idref="htm_rights" />')

        self.info_log('ファイル作成 - /OEBPS/rights.xhml')

    def create_oebps_content_opf(self):
        '''
        ファイル作成 - /OEBPS/content.opf
        '''

        replace_hash = self.settings

        # UUIDがない場合は作成
        if replace_hash['bookId'] == '':
            replace_hash['bookId'] = uuid4()

        # その他著者を作成
        other_authors = []
        other_author_count = 0
        if 'otherAuthors' in replace_hash and replace_hash['otherAuthors'] != None:
            for other_author in replace_hash['otherAuthors']:
                other_author_count += 1
                other_author['otherAuthorCount'] = str(other_author_count)
                author = '''
		<!-- Illustrator -->
		<dc:creator id="creator{replace:otherAuthorCount}">{replace:authorName}</dc:creator>
		<meta refines="#creator{replace:otherAuthorCount}" property="role" scheme="marc:relators" id="role">{replace:authorRole}</meta>
                '''
                author = Convert.replace_by_hash_data(
                    author, other_author, 'replace:')
                other_authors.append(author)
        replace_hash['otherAuthors'] = ''
        if other_author_count > 0:
            replace_hash['otherAuthors'] = '\n'.join(other_authors)

        manifests = []
        spines = []
        contents = [
            'resources',
            'styles',
            'cover',
            'readme',
            'title',
            'navigation',
            'chapters',
            'rights'
        ]
        for content in contents:
            if content in self.spines:
                for spines_resource in self.spines[content]:
                    spines.append(spines_resource)
            if content in self.manifests:
                for manifest_resource in self.manifests[content]:
                    manifests.append(manifest_resource)
        replace_hash['spines'] = '\n'.join(spines)
        replace_hash['manifests'] = '\n'.join(manifests)

        # content.opfファイル作成
        content_opf_data = '''
<?xml version="1.0" encoding="UTF-8"?>
<package xmlns="http://www.idpf.org/2007/opf" unique-identifier="BookID" version="3.0" xml:lang="ja">
	<metadata xmlns:dc="http://purl.org/dc/elements/1.1/">
		<!-- BookID -->
		<dc:identifier id="BookID">urn:uuid:{replace:bookId}</dc:identifier>
		<meta property="dcterms:identifier" id="uuid">urn:uuid:{replace:bookId}</meta>
		<!-- Language -->
		<dc:language>ja</dc:language>
		<meta property="dcterms:language" id="pub-lang">ja</meta>
		<!-- Modified -->
		<dc:date>{replace:modified}</dc:date>
		<meta property="dcterms:modified">{replace:modified}</meta>
		<!-- Title -->
		<dc:title>{replace:title}</dc:title>
		<meta property="dcterms:title" id="dcterm-title">{replace:title}</meta>
		<!-- Creator -->
		<dc:creator id="creatorMain">{replace:authorName}</dc:creator>
		<meta refines="#creatorMain" property="role" scheme="marc:relators" id="roleMain">{replace:authorRole}</meta>
        {replace:otherAuthors}
		<!-- Rights -->
		<dc:rights>{replace:authorCopyRight}</dc:rights>
		<meta property="dcterms:rights" id="rights">{replace:authorCopyRight}</meta>
		<!-- Cover -->
		<meta name="cover" content="cover-image" />
	</metadata>
	<manifest>
        {replace:manifests}
	</manifest>
	<spine page-progression-direction="{replace:pageProgressionDirection}">
        {replace:spines}
	</spine>
</package>
        '''
        content_opf_data = Convert.replace_by_hash_data(
            content_opf_data, replace_hash, 'replace:')

        oebps_content_opf_filepath = os.path.join(
            self.oebps_dirpath, 'content.opf')
        if FileSystem.exists_file(oebps_content_opf_filepath):
            FileSystem.remove_file(oebps_content_opf_filepath)
        with open(oebps_content_opf_filepath, 'w', encoding='utf-8') as f:
            f.write(content_opf_data.strip())

        self.info_log('ファイル作成 - /OEBPS/content.opf')

    def create_epub(self):
        '''
        epubファイル作成
        '''

        epub_filepath = os.path.join(
            self.args.output_dir, self.settings['title'] + '.epub')

        if FileSystem.exists_file(epub_filepath):
            FileSystem.remove_file(epub_filepath)
        with zipfile.ZipFile(epub_filepath, 'w', zipfile.ZIP_DEFLATED) as f:
            # mimetypeはzipファイルの先頭に、かつ圧縮なしで登録
            f.write(self.mimetype_filepath, 'mimetype', zipfile.ZIP_STORED)

            # META-INFディレクトリ登録
            filepaths = []
            FileSystem.collect_filepaths(self.meta_inf_dirpath, filepaths)
            for filepath in filepaths:
                f.write(filepath, filepath.replace(
                    self.args.output_dir, ''), zipfile.ZIP_DEFLATED)

            # OEBPSディレクトリ登録
            filepaths = []
            FileSystem.collect_filepaths(self.oebps_dirpath, filepaths)
            for filepath in filepaths:
                f.write(filepath, filepath.replace(
                    self.args.output_dir, ''), zipfile.ZIP_DEFLATED)

        self.info_log('ファイル作成 - ' + epub_filepath)

        # epub以外のファイル／ディレクトリを削除
        if self.args.debug_flag != '1':
            if FileSystem.exists_file(self.mimetype_filepath):
                FileSystem.remove_file(self.mimetype_filepath)

            if FileSystem.exists_file(self.meta_inf_dirpath):
                FileSystem.remove_directory(self.meta_inf_dirpath)

            if FileSystem.exists_file(self.oebps_dirpath):
                FileSystem.remove_directory(self.oebps_dirpath)

    def content_replace(self, content, replaces):
        '''
        コンテンツ置換
        '''

        simple_replaces = []
        regex_replaces = []

        for replace in replaces:
            if 'type' in replace:
                if replace['type'] == 'simple':
                    simple_replaces.append(replace)
                elif replace['type'] == 'regex':
                    regex_replaces.append(replace)
            else:
                simple_replaces.append(replace)

        # 最初に正規表現での置換を実行
        for replace in regex_replaces:
            content = re.sub(replace['placeHolder'],
                             replace['replaceContent'], content)

        # 単純置換を実行
        replace_hash = {}
        for replace in simple_replaces:
            replace_hash[replace['placeHolder']] = replace['replaceContent']
        content = Convert.replace_by_hash_data(
            content, replace_hash, 'replace:')

        return content

    def convert_yaml_to_list(self, parent_data, source, dest):
        '''
        YAMLファイルのデータを全て一次元配列に変換
        '''

        for key in source:
            if type(source[key]) == dict:
                self.convert_yaml_to_list(
                    parent_data + '.' + key, source[key], dest)
            elif type(source[key]) == list:
                counter = 0
                for data in source[key]:
                    counter += 1
                    self.convert_yaml_to_list(
                        parent_data + '.' + key + '.' + str(counter), data, dest)
            else:
                if key == 'filePath' and (parent_data.find('resource') > -1 or key.find('resource') > -1):
                    dest['$' + parent_data + '.' + key] = './resources/' + \
                        os.path.basename(source[key])
                else:
                    value = ''
                    if source[key] != None:
                        value = source[key]
                    dest['$' + parent_data + '.' + key] = value


if __name__ == '__main__':
    exit(Batch().execute())
